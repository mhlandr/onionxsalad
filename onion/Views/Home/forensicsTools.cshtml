@model onion.Models.ForensicsToolsViewModel
@{
    ViewData["Title"] = "Forensics Tool";
}

<h1>@ViewData["Title"]</h1>

<!--
    Form for inputting the website URL.
    This is your original post form, still intact.
-->
<form method="post" asp-action="Index" asp-controller="ForensicsTools">
    @Html.AntiForgeryToken()
    <div class="form-group">
        <label asp-for="WebsiteUrl"></label>
        <input asp-for="WebsiteUrl" id="websiteUrlInput" class="form-control" placeholder="Enter website URL" required />
        <span asp-validation-for="WebsiteUrl" class="text-danger"></span>
    </div>
    <button type="submit" class="btn btn-primary">Analyze</button>
</form>

<!-- Feature Section: Check if Website is Online -->
<div class="feature-section">
    <h3>Website Availability</h3>
    <button type="button" class="btn btn-secondary" onclick="checkOnlineStatus('@Model.WebsiteUrl', this)">Check if Online</button>
    <span class="online-status" style="margin-left:10px;"></span>
</div>

<!-- Feature Section: Capture Screenshot -->
<div class="feature-section" style="margin-top:20px;">
    <h3>Website Screenshot</h3>
    <button type="button" class="btn btn-secondary" onclick="captureScreenshot('@Model.WebsiteUrl', this)">Capture Screenshot</button>
    <div id="screenshot-container" style="margin-top:10px;">
        <img id="screenshot-preview" src="" alt="Screenshot" style="display: none; max-width: 100%; height: auto; border: 1px solid #ddd;">
    </div>
</div>
<!--
    New Feature Section: Analyze with AI
    Visible anytime, but it uses the URL from the same input box.
-->
<div class="feature-section" style="margin-top:20px;">
    <h3>AI Analysis of Website Source</h3>
    <button type="button" class="btn btn-secondary" onclick="analyzeWithAI()">Analyze with AI</button>
    <div id="aiAnalysisResult" style="margin-top:10px; white-space: pre-wrap;"></div>
</div>


@section Scripts {
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
   
    <!-- JavaScript to Handle Feature Interactions -->
    <script>
 
        // Retrieve the anti-forgery token from the hidden input
        const antiforgeryToken = document.querySelector('input[name="__RequestVerificationToken"]').value;

        async function analyzeWithAI() {
            const url = document.getElementById('websiteUrlInput').value;
            if (!url) {
                alert("Please enter a valid URL first.");
                return;
            }

            try {
                // Use a CORS proxy to fetch the website's full HTML
                const proxyUrl = "https://api.allorigins.win/get?url=" + encodeURIComponent(url);
                const websiteResponse = await fetch(proxyUrl);

                if (!websiteResponse.ok) {
                    throw new Error(`Failed to fetch website: ${websiteResponse.statusText}`);
                }

                const websiteData = await websiteResponse.json();
                const rawHtml = websiteData.contents; // Keep full HTML without filtering

                // Construct AI request
                const body = {
                    model: "Orenguteng/Llama-3.1-8B-Lexi-Uncensored_V2_Q5.gguf",
                    messages: [
                        { "role": "system", "content": "Make me a description of the website. Answer in english." },
                        { "role": "user", "content": `Here is the full content of the website:\n\n${rawHtml}` } // Use full HTML
                    ],
                    temperature: 0.7,
                    max_tokens: 2048,
                    stream: false
                };

                // Send the AI request
                const response = await fetch('http://localhost:1234/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    throw new Error(`Network response was not ok: ${response.statusText}`);
                }

                const data = await response.json();
                let aiResponse = data.choices?.[0]?.message?.content || "No response received.";

                // Remove <think> and </think> along with content inside
                aiResponse = aiResponse.replace(/<think>[\s\S]*?<\/think>/g, "").trim();

                document.getElementById('aiAnalysisResult').textContent = aiResponse;
            } catch (err) {
                console.error(err);
                document.getElementById('aiAnalysisResult').textContent = "Error: " + err.message;
            }
        }






        function checkOnlineStatus(url, button) {
            const apiUrl = '/Tor/CheckWebsiteStatus'; // Update if your endpoint differs

            // Ensure the URL has a proper scheme
            if (!url.startsWith("http://") && !url.startsWith("https://")) {
                url = "http://" + url;
            }

            // Update button state
            button.disabled = true;
            button.innerText = "Checking...";

            fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'RequestVerificationToken': antiforgeryToken
                },
                body: JSON.stringify({ onionUrl: url })
            })
                .then(response => response.json())
                .then(data => {
                    const statusSpan = button.nextElementSibling;
                    if (data.isOnline) {
                        statusSpan.textContent = "Online";
                        statusSpan.style.color = "green";
                    } else {
                        statusSpan.textContent = "Offline";
                        statusSpan.style.color = "red";
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('An error occurred while checking the website status.');
                })
                .finally(() => {
                    button.disabled = false;
                    button.innerText = "Check if Online";
                });
        }


        async function captureScreenshot(url, button) {
            const captureApiUrl = '/api/screenshot/capture'; // Update if your endpoint differs
            const statusApiUrl = '/api/screenshot/status/';   // Update if your endpoint differs

            try {
                // Update button state
                button.disabled = true;
                button.textContent = 'Capturing...';

                // Enqueue screenshot capture
                const response = await fetch(captureApiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': antiforgeryToken
                    },
                    body: JSON.stringify({ url: url })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to enqueue screenshot request');
                }

                const data = await response.json();
                const requestId = data.requestId;

                // Polling logic to check screenshot status
                const pollInterval = 1000; // 1 second
                const maxAttempts = 60; // 1 minute
                let attempts = 0;
                const imgElement = document.getElementById('screenshot-preview');

                const statusCheck = setInterval(async () => {
                    attempts++;

                    try {
                        const statusResponse = await fetch(`${statusApiUrl}${requestId}`, {
                            headers: { 'RequestVerificationToken': antiforgeryToken }
                        });

                        if (!statusResponse.ok) {
                            const errorData = await statusResponse.json();
                            throw new Error(errorData.error || 'Failed to get screenshot status');
                        }

                        const statusData = await statusResponse.json();

                        if (statusData.status === 'Completed') {
                            imgElement.src = statusData.screenshotPath;
                            imgElement.style.display = 'block';
                            button.textContent = 'Capture Screenshot';
                            clearInterval(statusCheck);
                            button.disabled = false;
                        } else if (statusData.status === 'Failed') {
                            clearInterval(statusCheck);
                            button.disabled = false;
                            button.textContent = 'Capture Screenshot';
                            alert('Screenshot capture failed: ' + statusData.errorMessage);
                        } else {
                            button.textContent = `Capturing... (${attempts}s)`;
                        }

                        if (attempts >= maxAttempts) {
                            clearInterval(statusCheck);
                            button.disabled = false;
                            button.textContent = 'Capture Screenshot';
                            alert('Screenshot capture timed out. Please try again later.');
                        }
                    } catch (pollError) {
                        clearInterval(statusCheck);
                        button.disabled = false;
                        button.textContent = 'Capture Screenshot';
                        console.error('Error while polling screenshot status:', pollError);
                        alert('An error occurred while checking the screenshot status. Please try again.');
                    }
                }, pollInterval);
            } catch (error) {
                console.error('Error capturing screenshot:', error);
                alert('An error occurred while capturing the screenshot: ' + error.message);
                button.disabled = false;
                button.textContent = 'Capture Screenshot';
            }
        }
    </script>
}
